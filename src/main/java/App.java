import com.google.common.collect.Lists;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class App {
    public String getGreeting() {
      return "Hello world.";
    }

    public static void main(String[] args) {
        App app = new App();
        System.out.println(isTriggerNotificationOnUpdateStudy());
        System.out.println(isTriggerNotificationOnUpdatePatient());
        app.updateNotificationFlag(notification_for_study, true);
        app.updateNotificationFlag(notification_for_patient, true);
        System.out.println(isTriggerNotificationOnUpdateStudy());
        System.out.println(isTriggerNotificationOnUpdatePatient());
    }

    private final static int no_notification = 0;
    private final static int notification_for_study = 1 << 0;
    private final static int notification_for_patient = 1 << 1;
    private final static int notification_default = no_notification | notification_for_study;

    private static int notificationValue = no_notification;

    private int updateNotificationFlag(int flag, boolean enabled) {
        DataAccessor<Integer> data = new DataAccessor<>(
            () -> notification_default,	// getter
            (x) -> notificationValue = x,		// setter
            (x) -> enabled ? (flag | x) : (~flag & x)											// mapper
        );
        return data.doMapBeforeSet();
    }

    private final class DataAccessor <T> {
        private Supplier<T> getter;
        private Consumer<T> setter;
        private Optional<Function<T,T>> mapper;

        DataAccessor(Supplier<T> getter, Consumer<T> setter, Function<T,T> mapper) {
            this.getter = getter;
            this.setter = setter;
            this.mapper = Optional.ofNullable(mapper);
        }

        T doMapBeforeSet() {
            T value = getter.get();
            T mappedValue = mapper.map(m -> m.apply(value)).orElse(value);
            setter.accept(mappedValue);
            return mappedValue;
        }
    }

    public static boolean isTriggerNotificationOnUpdateStudy() {
        return isTriggerNotification(notification_for_study);
    }

    public static boolean isTriggerNotificationOnUpdatePatient() {
        return isTriggerNotification(notification_for_patient);
    }

    private static boolean isTriggerNotification(int flag) {
        Function<Integer,Boolean> flagged = value -> (value & flag) != 0;
        return flagged.apply(getTriggerNotificationValue().orElse(notification_default));
    }

    private static Optional<Integer> getTriggerNotificationValue() {
        try {
            int value = notificationValue;
            //throw new RuntimeException("xxx");
            return Optional.of(value);
        } catch (Exception e) {
            return Optional.empty();
        }
    }

    public static void test(String[] args) {
        List<Integer> is = Lists.newArrayList(1,2,3,4,5,6,7,8,9,10);
        //is = Collections.EMPTY_LIST;

        double result = mean1(is);
        System.out.println("mean1=" + result);

        result = mean2(is, -1);
        System.out.println("mean2=" + result);

        Optional<Double> result3 = mean3(is);
        result3.ifPresent(x-> System.out.println("mean3=" + x));

        Patient p1 = new Patient("Lisa", 43);
        System.out.println("p1:" + p1);

        String nameFromInput = "abc";
        String ageFromInput = "123";

        //Patient p2 = Patient.valueOf(nameFromInput, Integer.parseInt(ageFromInput));
        //System.out.println(p2);

        if (nameFromInput != null && nameFromInput.trim().length() > 0) {
            try {
                int age = Integer.parseInt(ageFromInput);
                Patient p2 = Patient.valueOf(nameFromInput, age);
                System.out.println("p2:" + p2);
            } catch (NumberFormatException e) {
            }
        }

        Optional<Patient> p3 = Patient.valueOf(collectName(nameFromInput), collectAge(ageFromInput));
        p3.ifPresent(x-> System.out.println("p3:" + x));
        //p3.orElseThrow(IllegalArgumentException::new);

        Optional<Patient> p4 = map2(collectName(nameFromInput), collectAge(ageFromInput), Patient::valueOf);
        p4.ifPresent(x-> System.out.println("p4:" + x));

        Either<String, Patient> p5 = Patient.getEitherValueOf(collectName(nameFromInput), collectAge(ageFromInput));
        p5.ifPresent(x-> System.out.println("p5:" + x));
        p5.ifPresentLeft(y-> System.err.println("Error when p5:" + y));
    }

    static <T, U, R> Optional<R> map2(Optional<T> a, Optional<U> b, BiFunction<T, U, R> f) {
        return a.flatMap(aa->b.map(bb->f.apply(aa, bb)));
    }

    static Optional<String> collectName(String s) {
        if (s == null || s.trim().length() == 0) {
            return Optional.empty();
        } else {
            return Optional.of(s);
        }
    }

    static Optional<Integer> collectAge(String s) {
        try {
            return Optional.of(Integer.parseInt(s));
        } catch (NumberFormatException e) {
            return Optional.empty();
        }
    }

    static double mean1(List<Integer> is) {
        if (is.isEmpty()) {
            throw new IllegalArgumentException("Empty param is");
        }

        int sum = 0;
        for (Integer i : is) {
            sum += i;
        }
        return sum*1.0 / is.size();
    }


    static double mean2(List<Integer> is, double defaultValue) {
        Optional<Integer> sum = is.stream().reduce((x, y) -> x + y);
        return sum.map(x->x*1.0/is.size()).orElse(defaultValue);
    }

    static Optional<Double> mean3(List<Integer> is) {
        Optional<Integer> sum = is.stream().reduce((x, y) -> x + y);
        return sum.map(x->x*1.0/is.size());
    }

}

class Patient {
    String name;
    int age;
    Patient(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Patient " + name + " at age " + age;
    }

    public static Patient valueOf(String name, int age) {
        if (name == null) throw new IllegalArgumentException("Empty param name");
        return new Patient(name, age);
    }

    public static Optional<Patient> valueOf(Optional<String> name, Optional<Integer> age) {
        return name.flatMap(x->age.map(y->new Patient(x, y)));
    }

    public static Either<String, Patient> getEitherValueOf(Optional<String> name, Optional<Integer> age) {
        Optional<Patient> patient = name.flatMap(x->age.map(y->new Patient(x, y)));
        if (patient.isPresent()) {
            return Either.Right(patient.get());
        } else {
            if (!name.isPresent()) {
                return Either.Left("Empty param name");
            } else if (!age.isPresent()) {
                return Either.Left("Empty param age");
            } else {
                return Either.Left("Unknown reason");
            }
        }
    }
}

final class Either<E, R> {

    private static enum Name { LEFT, RIGHT }

    private final Name name;
    private final Optional<E> leftValue;
    private final Optional<R> rightValue;

    private Either(Optional<E> left, Optional<R> right, Name name) {
        leftValue = left;
        rightValue = right;
        this.name = name;
    }

    public static <E> Either Left(E value) {
        return new Either(Optional.ofNullable(value), Optional.empty(), Name.LEFT);
    }

    public static <R> Either Right(R value) {
        return new Either(Optional.empty(), Optional.ofNullable(value), Name.RIGHT);
    }

    public void ifPresentLeft(Consumer<? super E> f) {
        leftValue.ifPresent(x->f.accept(x));
    }

    public void ifPresent(Consumer<? super R> f) {
        rightValue.ifPresent(x->f.accept(x));
    }

    public <U> Optional<U> map(Function<? super R, ? extends U> f) {
        return rightValue.map(x->f.apply(x));
    }

    public<U> Optional<U> flatMap(Function<? super R, Optional<U>> f) {
        return rightValue.flatMap(x->f.apply(x));
    }
}
